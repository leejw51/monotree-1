[![Build Status](https://travis-ci.com/thyeem/monotree.svg?token=QYwxZ27j8uz6zsrzY6bk&branch=master)](https://travis-ci.com/thyeem/monotree)

# Monotree
Rust implementation of an optimized Sparse Merkle Tree.  
This is a kind of binary-radix tree based on bitwise branching, _currently_, no nibble of bit (nor a 4-bit neither a byte nibble).  
The branching unit is _just a single bit_, for now.  

## Features
- Very simple, concise and __easy to read__, but __fast__ and robust.  
- __Fully featured__ Sparse Merkle Tree (SMT) as a storage
- <ins>This includes: __non-inclusion proof__ , as well as __inclusion proof__, and its verification.</ins>
- Again, _NOT verbose_ at all.  

This library mostly relies on the _Rust standard library only_ except for `database APIs` and `hashers`.  
Currently, `monotree` supports these databases and hash functions following, but is designed to be super easy to customize and add:

_Databases include_:
- [`HashMap`](https://lib.rs/crates/hashbrown)
- [`RocksDB`](https://lib.rs/crates/rocksdb)
- [`Sled`](https://lib.rs/crates/sled)

_Hashers include_:
- [`Blake3`](https://lib.rs/crates/blake3)
- [`Blake2s`](https://lib.rs/crates/blake2-rfc) and [`Blake2b`](https://lib.rs/crates/blake2-rfc)
- [`SHA-2`](https://lib.rs/crates/sha2)
- [`SHA-3 (Keccak)`](https://lib.rs/crates/sha3)

## Quick Start
> _from `examples/basic.rs`_

> Regarding __non-inclusion proof__ and __inclusion proof__, See _Merkle proof_ section in <ins>More Examples</ins> below.   
```rust
use monotree::{Monotree, Result};
use monotree::utils::random_hash;

fn main() -> Result<()> {
    // Init a monotree instance
    // by default, with 'HashMap' and 'Blake3' hash function
    let mut tree = Monotree::default();

    // It is natural the tree root initially has 'None'
    let root = None;

    // Prepare a random pair of key and leaf.
    // random_hash() gives a fixed length of random array,
    // where Hash -> [u8; HASH_LEN], HASH_LEN = 32
    let key = random_hash();
    let leaf = random_hash();

    // Insert the entry (key, leaf) into tree, yielding a new root of tree
    let root = tree.insert(root.as_ref(), &key, &leaf)?;
    assert_ne!(root, None);

    // Get the leaf inserted just before. Note that the last root was used.
    let found = tree.get(root.as_ref(), &key)?;
    assert_eq!(found, Some(leaf));

    // Remove the entry
    let root = tree.remove(root.as_ref(), &key)?;

    // surely, the tree has nothing and the root back to 'None'
    assert_eq!(tree.get(root.as_ref(), &key)?, None);
    assert_eq!(root, None);
    Ok(())
}
```

## Performance
<ins>**All benchmarks were performed in a cumulative way**</ins>, where the root resulting from an operation just before was reused for subsequent operations.
They were carried out <ins>with randomly-generated bytes entries</ins> and <ins>from the root of an empty tree</ins>. (Deletion starts from the last root.)

> Tested on: _MacBook Pro (2.5 GHz Intel Core i7 and 16 GB 1600 MHz DDR3)_ with `rustc stable 1.42.0`   
> As a hasher, `Blake3` was used in this benchmark.

|  Op.   | DB used | #Entries | Time Measured | Std Error | per Op.  |
| :----: | :-----: | -------: | :-----------: | :-------: | :------: |
| Insert | HashMap |       10 |   17.69 us    |  0.15 us  | 1.77 us  |
| Insert | HashMap |      100 |   346.26 us   |  1.64 us  | 3.46 us  |
| Insert | HashMap |     1000 |    5.08 ms    |  0.02 ms  | 5.08 us  |
| Insert | HashMap |    10000 |   82.75 ms    |  0.14 ms  | 8.28 us  |
|  Get   | HashMap |       10 |   11.97 us    |  0.06 us  | 1.20 us  |
|  Get   | HashMap |      100 |   189.59 us   |  1.53 us  | 1.90 us  |
|  Get   | HashMap |     1000 |    2.55 ms    |  0.02 ms  | 2.55 us  |
|  Get   | HashMap |    10000 |   32.89 ms    |  0.08 ms  | 3.29 us  |
| Remove | HashMap |       10 |   28.08 us    |  0.20 us  | 2.81 us  |
| Remove | HashMap |      100 |   567.52 us   |  3.21 us  | 5.68 us  |
| Remove | HashMap |     1000 |    8.93 ms    |  0.04 ms  | 8.93 us  |
| Remove | HashMap |    10000 |   149.44 ms   |  0.25 ms  | 14.94 us |
|        |         |          |               |           |          |
| Insert | RocksDB |       10 |   45.79 us    |  0.59 us  | 4.58 us  |
| Insert | RocksDB |      100 |   754.03 us   |  5.86 us  | 7.54 us  |
| Insert | RocksDB |     1000 |   14.27 ms    |  0.08 ms  | 14.27 us |
| Insert | RocksDB |    10000 |   210.89 ms   |  0.17 ms  | 21.09 us |
|  Get   | RocksDB |       10 |   13.06 us    |  0.09 us  | 1.31 us  |
|  Get   | RocksDB |      100 |   212.67 us   |  1.31 us  | 2.13 us  |
|  Get   | RocksDB |     1000 |    2.83 ms    |  0.01 ms  | 2.83 us  |
|  Get   | RocksDB |    10000 |   36.60 ms    |  0.14 ms  | 3.66 us  |
| Remove | RocksDB |       10 |   74.11 us    |  1.39 us  | 7.41 us  |
| Remove | RocksDB |      100 |    1.30 ms    |  7.80 us  | 13.01 us |
| Remove | RocksDB |     1000 |   27.14 ms    |  0.10 ms  | 27.14 us |
| Remove | RocksDB |    10000 |   528.45 ms   |  1.75 ms  | 52.85 us |



## Integration tests and benchmark
performs integration tests with full combinations of operations and tree types consisting of _Databases_ and _Hashers_ included.

```bash
    ## Some tests are time consuming.
    ## --release is optional, but without it, it will take a longer time to complete the tests
    $ cargo test --release
```

performs a micro-benchmark based on [`Criterion`](https://crates.io/crates/criterion), with full combinations of operations and tree types consisting of _Databases_ and _Hashers_ included.

```bash
    $ cargo bench
```

and macroscopic-time benchmarks (but rather wider error bars) with all tree types were also prepared in _`examples/perf.rs`_.

```bash
    $ cargo run --release --example perf
```

and some examples describing how to manipulate `monotree`

```bash
    $ cargo run --example basic
    $ cargo run --example advanced
```

## Further improvement
`monotree` is a special case among the generalized binary radix trees, I'd like to call it `PoT (Power Of Two) radix tree`.   
<ins>If `monotree` were generalized with `pow(2, n)` of nibbles as a branching unit</ins>, _there would have been room for further performance improvement_.  

This generalization is now on progress.

## More Examples
> _from `examples/advanced.rs`_
```rust
fn main() -> Result<()> {
    // Init a monotree instance:
    // manually select a db and a hasher as your preference
    // Monotree::<DATABASE, HASHER>::new(DB_PATH)
    // where DATABASE = {MemoryDB, RocksDB, Sled}
    //         HASHER = {Blake3, Blake2s, Blake2b, Sha2, Sha3}
    let mut tree = Monotree::<RocksDB, Blake2b>::new("/tmp/monotree");

    // It is natural the tree root initially has 'None'
    let root = None;

    // Prepare 500 random pairs of key and leaf.
    // random_hashes() gives Vec<Hash>
    // where Hash is a fixed length of random array or [u8; HASH_LEN]
    let n = 500;
    let keys = random_hashes(n);
    let leaves = random_hashes(n);

    // Insert a bunch of entries of (key, leaf) into tree.
    // looks quite similar with 'monotree::insert()', but for insertion using batch.
    // 'inserts()' is much faster than 'insert()' since it's based on the following:
    // (1) DB batch-write, (2) sorting keys before insertion, and (3) mem-cache.
    let root = tree.inserts(root.as_ref(), &keys, &leaves)?;
    assert_ne!(root, None);

    // Similarly, there are methods 'gets()' and 'removes()' for batch use of
    // 'get()' and 'remove()', respectively.
    let result = tree.gets(root.as_ref(), &keys)?;
    assert_eq!(result.len(), keys.len());

    let root = tree.removes(root.as_ref(), &keys)?;
    // surely, the tree has nothing nad the root back to 'None'
    assert_eq!(root, None);

    /////////////////////////////////////////////////////////////////////
    // `Merkle proof` secion: verifying inclusion of data (inclusion proof)

    // `Monotree` has compressed representation, but it fully retains
    // the properties of the Sparse Merkle Tree (SMT).
    // Thus, `non-inclusion proof` is quite straightforward. Just go walk down
    // the tree with a key (or a path) given. If we cannot successfully get a leaf,
    // we can assure that the leaf is not a part of the tree.
    // The process of inclusion proof is below:

    // random pre-insertion for Merkle proof test
    let root = tree.inserts(root.as_ref(), &keys, &leaves)?;

    // pick a random key from keys among inserted just before
    let key = keys[99];

    // generate the Merkle proof for the root and the key
    let proof = tree.get_merkle_proof(root.as_ref(), &key)?;

    // To verify the proof correctly, you need to provide a hasher matched
    // Previously the tree was initialized with `Blake2b`
    let hasher = Blake2b::new();

    // get a leaf matched with the key: where the Merkle proof verification starts off
    let leaf = leaves[99];

    // verify the Merkle proof using all those above
    let verified = verify_proof(&hasher, root.as_ref(), &leaf, proof.as_ref());
    assert_eq!(verified, true);

    /////////////////////////////////////////////////////////////////////
    // Usage examples with some functional tests
    // Carefully trace the variable `root` as they are frequently shadowed.

    let mut tree = Monotree::default();
    let mut root = None;
    let hasher = Blake3::new();

    //--- insert/get and gen_proof/verify_proof over iterator
    for (i, (key, value)) in keys.iter().zip(leaves.iter()).enumerate() {
        // insert a key into tree
        root = tree.insert(root.as_ref(), key, value)?;

        // inserted a key and yields a root, where cumulative check-up goes on
        for (k, v) in keys.iter().zip(leaves.iter()).take(i + 1) {
            // check if the key-value pair was correctly inserted so far
            assert_eq!(tree.get(root.as_ref(), k)?, Some(*v));

            // generates a Merkle proof with all keys so far
            let proof = tree.get_merkle_proof(root.as_ref(), k)?;

            // verify the Merkle proof with all keys so far
            assert_eq!(
                verify_proof(&hasher, root.as_ref(), v, proof.as_ref()),
                true
            );
        }
    }
    assert_ne!(root, None);

    //--- insert/get and gen_proof/verify_proof after each deletion of entry
    for (i, (key, _)) in keys.iter().zip(leaves.iter()).enumerate() {
        assert_ne!(root, None);

        // assert that all other values are fine after each deletion
        for (k, v) in keys.iter().zip(leaves.iter()).skip(i) {
            // check in the same way as the previous example
            assert_eq!(tree.get(root.as_ref(), k)?, Some(*v));
            let proof = tree.get_merkle_proof(root.as_ref(), k)?;
            assert_eq!(
                verify_proof(&hasher, root.as_ref(), v, proof.as_ref()),
                true
            );
        }
        // delete a key and check if it was correctly removed
        root = tree.remove(root.as_ref(), key)?;
        assert_eq!(tree.get(root.as_ref(), key)?, None);
    }
    // must be back to inital state of tree
    assert_eq!(root, None);

    //--- faster way to insert/remove entries
    // Now tree is empty, and root is back to `None` again
    // Redo all those above using methods supporting batch operations
    root = tree.inserts(root.as_ref(), &keys, &leaves)?;
    assert_ne!(root, None);

    // Even if we shuffle the keys when removing,
    shuffle(&mut keys);

    // there's no difference. Back to `None` of root and empty tree again.
    // that's why the `root` plays a role as "state index of tree"
    root = tree.removes(root.as_ref(), &keys)?;
    assert_eq!(root, None);

    Ok(())
}
```